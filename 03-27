# environment diagram
03-27_env.eps
03-27_proc.eps

- (memo-fib 3)が呼び出されると、環境E1を指す新しい環境E2が作られる。E2内ではxに3がバインドされている。
- tableをlookupすると、3に対応する値は見つからないので、(f 3)が呼び出される。環境E0においてfに(lambda (n) ...)がバインドされている。
- (f 3)の呼出により、手続きfが指している環境E0を指す、新しい環境E3が作られる。E3内ではnに3がバインドされている。
- (lambda (n) ...)を評価することにより、まず(memo-fib 2)が呼び出される（(memo-fib 1)はあとで呼び出される）。

- (memo-fib 2)の呼出により、環境E1を指す新しい環境E4が作られる。E4内ではxに2がバインドされている。先と同様の手順を辿り、(f 2)が呼び出され（環境E5）、さらに(memo-fib 1)が呼び出される（環境E6）。
- 環境E6から(f 1)（環境E7）が呼び出され、そこで値1が返される。
- 環境E6に戻り、そこで手続きinsert!が呼び出され、tableの値が更新される。
- 環境E5に戻り、(memo-fib 0)（環境E7）が呼び出される。
- 環境E7,E8,E7,E5,E4と辿って、tableの中身は図の一番下のような状態になる。
- 環境E3に戻り、(memo-fib 1)が呼び出される（環境E9）。
- 環境E9では手続きlookupから値が決定される。
- 最後に環境E3で値2が返され、環境E2でtableに(3 . 2)が挿入される。そして値2が返される。


# 計算量について
memo-fibでは、tree-recursionでフィボナッチ数を計算する手続きと違って、同じ数について複数回フィボナッチ数を計算することはない。したがって、その計算量はたかだかnの定数倍となる。


# memo-fibを単に(memoize fib)としてよいか
よくない。後者では最後に導き出される値だけがtableに記録され、計算過程の値は記録されない。すなわちメモ化が行われない。ゆえに計算量が大きくなる。
